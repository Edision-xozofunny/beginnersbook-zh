# DBMS 查看可串行化

> 原文： [https://beginnersbook.com/2018/12/dbms-view-serializability/](https://beginnersbook.com/2018/12/dbms-view-serializability/)

在上一个教程中，我们学习了[冲突可串行化](https://beginnersbook.com/2018/12/dbms-conflict-serializability/)。在本文中，我们将讨论另一种可串行化，即 **查看可串行化** 。

## 什么是查看可串行化？

查看可串行化是一个查找给定[调度](https://beginnersbook.com/2018/12/dbms-schedules/)视图是否可串行化的过程。

要检查给定的调度是否可视化串行化，我们需要检查给定的调度是否对其序列调度 **查看等价**。让我们举个例子来理解我的意思。

**给定调度：**

```
T1        T2
-----     ------
R(X)
W(X)
          R(X)
          W(X)
R(Y)
W(Y) 
          R(Y)
          W(Y)

```

**以上给定调度的串行调度：**

我们知道在[串行调度](https://beginnersbook.com/2018/12/dbms-schedules/)中，只有在当前运行的事务完成时才会启动事务。所以上面给出的调度的连续调度如下所示：

```
T1        T2
-----     ------
R(X)
W(X)
R(Y)
W(Y)
          R(X)
          W(X)
          R(Y)
          W(Y)

```

如果我们能够证明给定的调度对其连续调度 **查看等价**，那么给定的调度称为**视图可串行**。

## 为什么我们需要查看可串行化？

我们知道，串行调度永远不会使数据库处于不一致状态，因为没有并发事务执行。但是，非串行调度可能会使数据库处于不一致状态，因为有多个事务同时运行。通过检查给定的非串行调度是否可视化串行化，我们确保它是一致的调度。

您可能想知道不是检查非串行调度是否可串行化，我们不能一直有串行调度吗？答案是否定的，因为事务的并发执行充分利用了系统资源，并且与串行调度相比要快得多。

## 查看等效

让我们学习如何检查两个调度是否相同。

如果它们满足以下所有条件，则称两个调度`T1`和`T2`是等效视图：

1\. **初始读取：**事务中每个数据项的初始读取必须在两个调度中都匹配。例如，如果事务`T1`在调度`S1`中的事务`T2`之前读取数据项`X`，则在调度`S2`中，`T1`应该在`T2`之前读取`X`。

**读取与初始读取：**您可能会对术语初始读取感到困惑。这里初始读取意味着对数据项的第一次读取操作，例如，数据项`X`可以在调度中多次读取，但是对`X`的第一次读取操作称为初始读取。一旦我们在同一篇文章的下一部分中得到示例，这将更加清晰。

2\. **最终写入：**每个数据项的最终写操作必须在两个调度中都匹配。例如，数据项`X`最后由事务`T1`在调度`S1`中写入，然后在`S2`中，对`X`的最后一次写操作应该由事务`T1`执行。

3\. **更新读取：**如果在调度`S1`中，事务`T1`正在读取由`T2`更新的数据项，则在调度`S2`中，`T1`应该在相同数据项上的`T2`写操作之后读取该值。例如，在调度`S1`中，`T1`在`X`上执行写入操作后对`X`执行读取操作，然后在 `S2`中，`T1`在`T2`执行写入操作后读取`X`。

## 查看可串行

如果调度视图等同于其序列调度，那么给定的调度称为查看可串行。让我们举个例子。

### 查看可串行化示例

![DBMS View Serializability](img/0fd7488ef319240d2749eba146c9067b.jpg)

让我们检查一下可串行化的三个条件：

#### 初始读取

在调度`S1`中，事务`T1`首先读取数据项`X`.在`S2`中，事务`T1`首先读取数据项`X`.

让我们检查`Y`.在调度`S1`中，事务`T1`首先读取数据项`Y`.在`S2`中，`Y`上的第一次读操作由`T1`执行。

我们检查了数据项`X`和在`S1`和`S1`中满足`Y`和**初始读取**条件。

#### 最终写入

在调度`S1`中，`X`上的最终写操作由事务`T2`完成。在`S2`中，事务`T2`也在`X`上执行最终写入。

让我们检查`Y`.在调度`S1`中，`Y`上的最终写操作由事务`T2`完成。在调度`S2`中，`Y`上的最终写入由`T2`完成。

我们检查了数据项`X`和`Y`，在`S1`和`S2`中，**最终写入**条件得到满足。

#### 更新读取

在`S1`中，事务 T2 读取由 T1 写入的 X 的值。在 S2 中，相同的事务 T2 在 T1 写入之后读取 X.

在`S1`中，事务`T2`读取由`T1`写入的`Y`的值。在`S2`中，相同的事务`T2`在`T1`更新之后读取`Y`的值。

两个调度也满足更新读取条件。

**结果：**由于在该示例中满足检查两个调度是否是视图等效的所有三个条件，这意味着`S1`和`S2`是视图等效的。而且，正如我们所知，调度`S2`是`S1`的连续调度，因此我们可以说调度`S1`是视图可串行化调度。