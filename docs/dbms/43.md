# DBMS 冲突可串行化

> 原文： [https://beginnersbook.com/2018/12/dbms-conflict-serializability/](https://beginnersbook.com/2018/12/dbms-conflict-serializability/)

在 [DBMS 调度](https://beginnersbook.com/2018/12/dbms-schedules/)指南中，我们了解到有两种类型的调度 - 串行和调度。非串联。串行调度不支持并发执行事务，而非串行调度支持并发。我们还在[可串行化](https://beginnersbook.com/2018/12/dbms-serializability/) 教程中了解到，非串行调度可能会使数据库处于不一致状态，因此我们需要检查这些非串行调度以获得可串行化。

**冲突可串行化**是可串行化类型之一，可用于检查非串行调度是否可冲突串行化。

## 什么是冲突可串行化？

如果我们可以在交换其非冲突操作后将其转换为串行调度，则调度称为冲突可串行化。

### 冲突的操作

如果它们满足以下三个条件，则说两个操作存在冲突：

1. 这两项业务都属于不同的事务。
2. 两个操作都在同一个数据项上运行。
3. 至少有一个操作是写操作。

让我们看一些例子来理解这一点：

**例 1：**事务`T1`的操作`W(X)`和事务`T2`的操作`R(X)`是冲突操作，因为它们满足上述所有三个条件。它们属于不同的事务，它们正在处理相同的数据项 X，这是写操作中的一个操作。

**示例 2：**类似地，`T1`的操作`W(X)`和`T2`的`W(X)`是冲突操作。

**例 3：**`T1`的操作`W(X)`和`T2`的`W(Y)`是非冲突操作，因为两个写操作都不在同一数据项上工作，因此这些操作不满足第二个条件。

**例 4：**类似地，`T1`的`R(X)`和`T2`的`R(X)`是非冲突操作，因为它们都不是写操作。

**示例 5：**类似地，`T1`的`R(X)`和`T1`的`W(X)`是非冲突操作，因为两个操作属于同一事务`T1`。

## 冲突等价调度

如果在交换非冲突操作之后可以将一个调度转换为其他调度，则称两个调度是冲突等效。

## 冲突可串行化检查

让我们检查一个调度是否可以冲突串行化。如果调度冲突等同于其序列调度，则称为冲突可串行化调度。让我们举几个调度的例子。

### 冲突可串行化的示例

让我们考虑这个调度：

```
T1         T2
-----     ------
R(A)
R(B)
          R(A)
          R(B)
          W(B)
W(A)

```

要将此调度转换为连续调度，我们必须将事务`T2`的`R(A)`操作与事务`T1`的`W(A)`操作交换。但是我们不能交换这两个操作，因为它们是冲突操作，因此我们可以说这个给定的调度是**而不是冲突可串行化**。

让我们再看一个例子：

```
T1         T2
-----     ------
R(A)
          R(A)
          R(B)
          W(B)
R(B)
W(A)

```

让**交换非冲突操作**：

在交换`T1`的`R(A)`和`T2`的`R(A)`后，我们得到：

```
T1         T2
-----     ------
          R(A)
R(A)
          R(B)
          W(B)
R(B)
W(A)

```

在交换`T1`的`R(A)`和`T2`的`R(B)`后，我们得到：

```
T1         T2
-----     ------
          R(A)
          R(B)
R(A) 
          W(B)
R(B)
W(A)

```

在交换`T1`的`R(A)`和`T2`的`W(B)`后，我们得到：

```
T1         T2
-----     ------
          R(A)
          R(B)
          W(B)
R(A)         
R(B)
W(A)

```

在交换所有非冲突操作后，我们终于得到了一个连续的调度，因此我们可以说给定的调度是**冲突可串行化**。